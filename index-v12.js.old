const Discord = require("discord.js");
const client = new Discord.Client;
var moment = require('moment-timezone');
const config = require("./config.json")
moment().tz("Europe/Paris");
moment.locale("fr");
const {getConnection} = require("./db/db.js")

const users = require("./users.json").users;


client.once("ready", () => {
  console.log("Logged as " + client.user.tag + "(" + client.user.id + ")")
  console.log("User to check:" + users.length)
  console.log("Starting prossec...")
  getConnection().connect(function(err) {
    if (err) throw err;
    console.log("Connecté à la base de données MySQL!");
  });


  checkUser()
  setInterval(function () {
    checkUser() // check tout les 15 secondes
    console.log("Checked.")
  }, 15 * 1000)

})

client.on("message", async (message) => {
  if (message.author.bot) return;
  if (message.member.hasPermission('ADMINISTRATOR')) {
    if (message.content === config.prefix + "stop") return message.reply("Pour arreter le bot, vous devez faire `s.stop confirm`\n:warning: Le seul moyen de redemarer le bot serra de depuis le panel ! :warning:")

    else if (message.content === config.prefix + "stop confirm") {
      await message.reply("Le bot va s'arreter.")
      await console.log("Une demmande d'arret a été demandé par " + message.author.tag + " à " + new moment())
      client.destroy();
    } else if (message.content === config.prefix + "verify") {

      checkUser()
    }
  }
})


require("./server.js")();
client.login(config.token)

async function checkUser(channelAnn) {
  // let users = require("./users.json").users
  //const userSchema = require("./db/schemas/user-schema.js")
  getConnection().query("SELECT * FROM users" , (err, result) => {
    if(err)throw err;
    result.forEach(async(userR) => {
      const user = client.users.cache.get(userR.id)
      if (user.presence.status === "idle" || user.presence.status === "online" || user.presence.status === "dnd") {
        let time = new Date().toISOString()
          if (userR.status === "online") return;
  
          else{
          /*  await dbFunc.find(userSchema, {}, (err, resultat) => {
              if(err) return console.error(err)
              console.log(resultat)
            })*/
            getConnection().query("UPDATE users SET status = 'online', connectedAt = '" + time + "' WHERE id = '" +userR.id + "'", (err) => {if(err)throw err});
            sendToAllChannelEmbed(user.tag, user.displayAvatarURL({
                  dynamic: true
                }), user.tag + " c'est connecté !", "À: " + moment(time).format("HH[h]mm [et] SS [secondes le ] Do MMMM YYYY") + "\nDéconnecté pendant: " + moment(userR.lastseen).fromNow(true), "12B533")
              console.log("on")
          }
      } else if (user.presence.status === "offline") {
        let time = new Date().toISOString()
  
          if (userR.status === "offline") return;
          else {
            console.log('off')
            sleep(10)
            getConnection().query("UPDATE users SET status = 'offline', lastseen = '" + time + "' WHERE id = '" +userR.id + "'", (err) => {if(err)throw err});
                sendToAllChannelEmbed(user.tag, user.displayAvatarURL({
                  dynamic: true
                }), user.tag + " c'est déconecté !", "À: " + moment(time).format("HH[h]mm [et] SS [secondes le ] Do MMMM YYYY") + "\nConnecté pendant :" + moment(userR.connectedAt).fromNow(true))
          }
      }
    });

  })
  
}


async function sendToAllChannelEmbed(authorName, authorAvatarUrl, title, description, color) {
  // const channelSchema = require("./db/schemas/channel-schema.js")
 	getConnection().query("SELECT * FROM `channels`",(err, result) => {
    if(err)return console.error(err)
    result.forEach(value => {
      const channel = client.channels.cache.get(value.channel_id);
      channel.send({
        embed: {
          author: {
            name: authorName,
            icon_url: authorAvatarUrl,
          },
          title: title,
          color: color,
          description: description
        }
      })
    })
  })
}

function sleep(milliseconds) {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}
